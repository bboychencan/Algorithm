# 525. Contiguous Array

这一天一个月内先后尝试了两次，都失败了，看了答案之后发现本身并没有很难，只是用到了一个小的trick我从来没有遇到过。

看到题目后第一反应是，这道题很像two pointers或者sliding window的题目，我开始琢磨通过移动前后两个指针或者从start和end开始把数组向内压缩，试图找到压缩过程中的规律从而可以把对数组的遍历从n^2次降低到n次。

这种尝试花费了我将近一个小时，似乎能够捋出一点规律，但是很容易就被一些corner case的fail了。

我还试图用dp，先计算presum，从两个方向进攻，依然没有头绪，因为遇到0或者1之后下一步该如果操作很难判断，或者说没有明确的规律。


翻看答案后，发现有一条很重要的思想我没有想到过，那就是把曾经出现过的presum用hashmap存储下来，这样同样的presum值再次出现后就意味着，新添加的一段数组中0和数目相同。

数组中0和1的个数相同这件事情，可以通过把0转化为-1，然后求和为0得到简化，这一点很巧妙。 不知道为什么没有想到。 这样就把0和1数目相同这个问题变成了和为零的问题
