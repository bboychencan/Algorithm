# 956. Tallest Billboard

这道题猛一看还以为不难，标准的背包问题，稍微仔细想了下，感觉有点麻烦，需要拼出两个一样的长度而且有可能有剩余不用的rod，发现这个比较难捋清了。

不过还是写了个背包方法，dp[i]里面存储拼接长度为i是的所有拼接组合，然后每次遍历的时候都判断i/2的所有组合情况，找出i和i/2里面没有共同元素的组合方式，然后就可以得到一个解。遍历完所有i，所有解中最大值即为答案，结果TLE。。。

过了半个月回头再想这道题，还是没有更好的思路，唯一的就是把选取状态压缩到01的数字中，避免存储一些列的set，感觉应该会降低时间复杂度。

看了答案，结果发现大家用了二维的数组去存背包状态，我试图往这个方向去想过，但是没有很明确的思路，所以也放弃了。

隔了几天yong状态压缩去实现了上面的想法，仍然是TLE。

看了一些答案，感觉很多把问题搞复杂了，其实还是不需要二维数组。这依然是一个背包问题，但是唯一的变种就是，这不再是0-1背包问题，而是0，1or-1背包问题。每次判断的不光是加入或不加入当下元素，而是判断是加，是减，或者忽略这三种情况，遍历所有三种情况，存储最优值即可。 这可以算上背包的变形，第一次遇到，值得记住！～
