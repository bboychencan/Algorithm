# 思路
这一题看完题目，第一反应就是状态压缩dp，正好前两天专门学习了一下，想着说应该没问题。
最后也做出来了，但是花的时间比较多，看了下排名前几的答案都是几分钟就写完了。。。 惊叹。
仔细研究了下高手的答案，学到了很多。
首先这道题确实是道状压题，但是压缩方式可以更巧妙，dp的值可以像背包一样bottom-up去存储，
而不用把所有中间结果存储下来，因为这里的dp[i]只和dp[i-1]有关，由于这个性质所以只需要
一维的dp数组即可。

# code
先贴下我自己的代码。
```python
class Solution:
    def numOfWays(self, n: int) -> int:
# red 0 
# yellow 1
# green 2
# 010 000010000
# 101 010000010
# 201 100000010

# 012 000010100
# 102 010000100
# 202 100000100

# 020 000100000
# 120 010100000
# 210 100010000

# 021 000100010
# 121 010100010
# 212 100010100
        status = [int('000010000',2), 
                  int('010000010',2), 
                  int('100000010',2), 
                  int('000010100',2),
                  int('010000100',2),
                  int('100000100',2),
                  int('000100000',2),
                  int('010100000',2),
                  int('100010000',2),
                  int('000100010',2),
                  int('010100010',2),
                  int('100010100',2)]
        dp = [[0 for i in range(n+1)] for i in range(300)]
        for x in status:
            dp[x][1] = 1
            
        for i in range(2, n + 1):
            for x in status:
                for y in status:
                    temp = x ^ y
#                     print('debug', bin(x), bin(y), bin(temp))
                    if temp % (1 << 3) == 0 \
                        or (temp >> 3) % (1<<3) == 0 \
                        or (temp >> 6) % (1<<3) == 0:
#                         print('here')
                        continue
                    else:
                        dp[x][i] += dp[y][i-1]
        res = 0
        for x in status:
#             print(x, bin(x), dp[x][1], dp[x][2])
            res += dp[x][n]
        return res % (10 ** 9 + 7)
```

分析一下，首先这个状态编码，我想到了一个很古怪的方法，因为我只知道二进制的压缩，但是三进制的压缩我一下子犯难了。
看了一下答案，感觉自己好笨，三进制同样可以映射到integer，只要把三进制转integer的规则在代码中实现即可。(x * 9 + y * 3 + z)

另外一个可以优化的点就是dp的状态不需要全部存储，这个和背包是一样的，是因为这里的状态转移满足dp[i]只依赖于dp[i-1]。
真是学到了!
